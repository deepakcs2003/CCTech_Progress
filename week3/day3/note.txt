## ğŸ“˜ TypeScript Function Types (Beginner Friendly Notes)

You are learning very well ğŸ‘
Now letâ€™s understand **TypeScript Functions Type** in a very simple and clear way.

---

# ğŸ”¹ What is a Function Type in TypeScript?

In **TypeScript**, function types define:

* âœ… What type of parameters a function accepts
* âœ… What type of value it returns

This helps:

* Prevent errors
* Make code safer
* Improve readability

---

# ğŸŸ¢ Basic Function Syntax (Very Important)

```ts
function functionName(parameter1: type, parameter2: type): returnType {
    // function body
    return value;
}
```

### ğŸ” Syntax Explanation

* `function` â†’ keyword to create a function
* `functionName` â†’ name of the function
* `parameter1: type` â†’ parameter with its type
* `: returnType` â†’ type of value the function returns
* `{ }` â†’ function body

---

# 1ï¸âƒ£ Named Function

A named function has a proper name.

### âœ… Syntax

```ts
function functionName(args: type): returnType { }
```

### âœ… Example

```ts
function add(a: number, b: number): number {
    // a and b are numbers
    return a + b; // returning a number
}

console.log(add(3, 4)); // Output: 7
```

### âœ” Explanation

* `a: number` â†’ a must be number
* `b: number` â†’ b must be number
* `: number` â†’ function returns number

---

# 2ï¸âƒ£ Anonymous Function

An anonymous function has **no name**.
It is stored inside a variable.

### âœ… Syntax

```ts
const variableName = function(args: type): returnType { }
```

### âœ… Example

```ts
const subtract = function(a: number, b: number): number {
    // anonymous function assigned to subtract
    return a - b;
};

console.log(subtract(5, 2)); // Output: 3
```

âœ” The function does not have a name.
âœ” We call it using the variable `subtract`.

---

# 3ï¸âƒ£ Arrow Function (Very Important)

Arrow functions use `=>`.

### âœ… Syntax

```ts
const variableName = (args: type): returnType => {
    return value;
};
```

OR short form:

```ts
const variableName = (args: type): returnType => expression;
```

### âœ… Example

```ts
const multiply = (a: number, b: number): number => {
    return a * b; // returning multiplication
};

console.log(multiply(2, 5)); // Output: 10
```

### âœ” Short Version

```ts
const multiply = (a: number, b: number): number => a * b;
```

âœ” Arrow functions are shorter
âœ” Mostly used in callbacks

---

# 4ï¸âƒ£ Optional and Default Parameters

## ğŸ”¹ Optional Parameter (`?`)

`?` means the parameter is optional.

### Syntax

```ts
function functionName(param1: type, param2?: type): returnType { }
```

---

## ğŸ”¹ Default Parameter

You can give a default value.

### Example

```ts
function greet(firstName: string, lastName: string = "Doe"): string {
    // lastName has default value "Doe"
    return `Hello, ${firstName} ${lastName}`;
}

console.log(greet("John")); 
// Output: Hello, John Doe

console.log(greet("Joe", "Smith"));
// Output: Hello, Joe Smith
```

âœ” If no lastName â†’ uses "Doe"
âœ” If value given â†’ overrides default

---

# 5ï¸âƒ£ Return Type

Return type tells what type the function gives back.

### Syntax

```ts
function functionName(parameters): returnType {
    return value;
}
```

### Example

```ts
function square(num: number): number {
    // num must be number
    return num * num; // returns number
}

console.log(square(4)); // Output: 16
```

âœ” Always try to write return type (good practice)

---

# 6ï¸âƒ£ Void Return Type

`void` means â†’ function does NOT return anything.

### Syntax

```ts
function functionName(parameters): void {
    // no return value
}
```

### Example

```ts
function logMessage(message: string): void {
    console.log(message); // only prints
}

logMessage("Hello, Rahul!");
```

âœ” Used for logging
âœ” Used for side effects
âœ” No return value

---

# 7ï¸âƒ£ Rest Parameters

Rest parameters allow multiple values.

### Syntax

```ts
function functionName(...args: type[]): returnType { }
```

### Explanation of Syntax

* `...` â†’ rest operator
* `args: type[]` â†’ array of that type

---

### Example

```ts
function sum(...numbers: number[]): number {
    // numbers is an array of numbers
    return numbers.reduce((acc, curr) => acc + curr, 0);
}

console.log(sum(1, 2, 3, 4, 5)); 
// Output: 15
```

âœ” Accepts many numbers
âœ” Stores them in array

---

# 8ï¸âƒ£ Function Overloading

Overloading means:

ğŸ‘‰ Same function name
ğŸ‘‰ Different parameter types or count

### Syntax

```ts
function functionName(param1: type): returnType;
function functionName(param1: type, param2: type): returnType;

function functionName(param1: type, param2?: type): returnType {
    // actual implementation
}
```

---

### Example

```ts
// Overload signatures
function greet(person: string): string;
function greet(person: string, age: number): string;

// Implementation
function greet(person: string, age?: number): string {
    if (age !== undefined) {
        return `Hello, ${person}, you are ${age} years old!`;
    }
    return `Hello, ${person}!`;
}

console.log(greet("Anne"));
console.log(greet("John", 30));
```

âœ” First signature â†’ 1 parameter
âœ” Second signature â†’ 2 parameters
âœ” One implementation handles both

---

# 9ï¸âƒ£ Callback Function

A callback is a function passed inside another function.

### ğŸ”¹ Callback Type Syntax (Very Important)

```ts
(result: number) => void
```

Meaning:

* Takes `number`
* Returns nothing (`void`)

---

### Example

```ts
function performOperation(
    a: number,
    b: number,
    callback: (result: number) => void // callback type
): void {

    let result = a + b; // add numbers
    callback(result);   // calling callback
}

performOperation(3, 4, (result) => {
    console.log(result); // Output: 7
});
```

âœ” `callback` is a function
âœ” It receives result
âœ” It returns nothing

---

# â­ Best Practices

âœ” Always write return type
âœ” Use arrow functions for callbacks
âœ” Use optional/default carefully
âœ” Use overloading only when necessary

---

# ğŸ¯ Final Summary (Very Important)

| Concept        | Meaning                         |
| -------------- | ------------------------------- |
| `: type`       | Defines variable/parameter type |
| `: returnType` | Defines return type             |
| `?`            | Optional parameter              |
| `=`            | Default value                   |
| `void`         | No return                       |
| `...`          | Rest parameter                  |
| `=>`           | Arrow function                  |

---

If you want, I can also create:

* ğŸ”¹ Practice questions
* ğŸ”¹ Simple exercises
* ğŸ”¹ Real-life examples
* ğŸ”¹ Interview questions

You are improving step by step ğŸ’ª Keep going!

# ğŸ“˜ TypeScript Call Signatures (Beginner Friendly Explanation)

Now we will learn **Call Signatures** in a very simple way ğŸ˜Š

---

# ğŸ”¹ What is a Call Signature?

A **Call Signature** allows:

âœ… An object to behave like a function
âœ… That same object to also have properties

Normally:

* Functions â†’ can be called
* Objects â†’ have properties

ğŸ‘‰ Call signatures combine both.

---

# ğŸ”¹ Why Do We Use Call Signatures?

They help us:

* Create function-like objects
* Add extra properties to functions
* Keep code flexible and type-safe

---

# ğŸ”¹ Basic Syntax (Very Important)

```ts
type MyCallableObject = {
    (parameter1: Type1, parameter2: Type2): ReturnType;
    propertyName: PropertyType;
};
```

---

# ğŸ” Step-by-Step Syntax Explanation

### 1ï¸âƒ£ `type`

Used to create a **type alias**.

```ts
type TypeName = { }
```

---

### 2ï¸âƒ£ `(parameter1: Type1, parameter2: Type2): ReturnType`

This part defines:

* Parameters
* Their types
* Return type

It looks like a function
BUT it is inside an object type.

---

### 3ï¸âƒ£ `propertyName: PropertyType`

This defines an extra property.

So this type means:

ğŸ‘‰ â€œThis object can be called like a functionâ€
ğŸ‘‰ â€œAnd it also has propertiesâ€

---

# ğŸŸ¢ Example 1: Greeting Function Using Call Signature

---

## âœ… Type Definition

```ts
type GreetingFunction = {
    (name: string): string;  // callable part (function signature)
    description: string;     // extra property
};
```

### ğŸ” Understanding This Type

* `(name: string): string`
  â†’ Takes a string
  â†’ Returns a string

* `description: string`
  â†’ Has a property called description
  â†’ That property must be string

---

## âœ… Implementation

```ts
const greet: GreetingFunction = (name: string) => {
    // This function matches the call signature
    return `Hello, ${name}!`; // returns string
};

// Adding property to function
greet.description = "A function to greet users";

// Calling the function
console.log(greet("Alice"));  

// Accessing property
console.log(greet.description);
```

---

## âœ… Output

```
Hello, Alice!
A function to greet users
```

---

## ğŸ” What Happened Here?

âœ” `greet` behaves like a function
âœ” `greet` also has a property called `description`
âœ” TypeScript checks both

This is the power of call signatures ğŸ’ª

---

# ğŸŸ¢ Example 2: Calculator Using Call Signature

---

## âœ… Type Definition

```ts
type Calculator = {
    (a: number, b: number): number; // callable part
    operation: string;              // property
};
```

### ğŸ” Meaning

* Takes two numbers
* Returns a number
* Has a property called `operation`

---

## âœ… Implementation

```ts
// Addition function
const add: Calculator = (a: number, b: number) => {
    return a + b; // returns number
};

// Adding property
add.operation = "Addition";

// Multiplication function
const multiply: Calculator = (a: number, b: number) => {
    return a * b; // returns number
};

// Adding property
multiply.operation = "Multiplication";

// Using them
console.log(`${add.operation}: ${add(5, 3)}`);
console.log(`${multiply.operation}: ${multiply(5, 3)}`);
```

---

## âœ… Output

```
Addition: 8
Multiplication: 15
```

---

# ğŸ¯ Important Concept to Remember

Normal function type:

```ts
type MyFunction = (a: number) => number;
```

Call signature type:

```ts
type MyCallable = {
    (a: number): number;
    property: string;
};
```

ğŸ‘‰ Difference:

| Normal Function Type | Call Signature        |
| -------------------- | --------------------- |
| Only callable        | Callable + properties |
| Simple               | More flexible         |

---

# ğŸ§  When Should You Use Call Signatures?

Use when:

* You want a function with metadata
* You want function + configuration together
* You are designing libraries
* You need advanced typing

---

# â­ Final Summary (Very Important)

âœ” Call signature defines a callable object
âœ” Written inside object type `{ }`
âœ” Looks like function syntax inside object
âœ” Allows extra properties

---

# ğŸ”¥ Quick Practice

Try creating:

```ts
type Logger = {
    (message: string): void;
    level: string;
};
```

Now create a function that:

* Prints message
* Has property `level = "INFO"`

# ğŸ“˜ Optional Parameters in TypeScript (Beginner Friendly Explanation)

Now we will understand **Optional Parameters** in a very simple way ğŸ˜Š

---

# ğŸ”¹ What Are Optional Parameters?

Optional parameters allow a function to be called **without passing all arguments**.

ğŸ‘‰ This makes functions more flexible
ğŸ‘‰ Improves readability
ğŸ‘‰ Avoids unnecessary arguments

---

# ğŸ”¹ How Do We Define Optional Parameters?

We use a **question mark `?`** after the parameter name.

---

# ğŸ”¹ Important Rules

âœ… Use `?` after parameter name
âœ… Optional parameters must come **after required parameters**
âœ… If not provided â†’ value becomes `undefined`

---

# ğŸ”¹ Basic Syntax (Very Important)

```ts
function functionName(param1: type, param2?: type): returnType {
    // function body
}
```

---

# ğŸ” Syntax Explanation (Step by Step)

* `param1: type` â†’ required parameter
* `param2?: type` â†’ optional parameter
* `?` â†’ means this parameter may or may not be provided
* `: returnType` â†’ type of value returned

---

# ğŸŸ¢ Example 1: Greeting Function with Optional Parameter

---

## âœ… Code

```ts
function greet(name: string, greeting?: string): string {
    // name is required
    // greeting is optional

    if (greeting) {
        // if greeting is provided
        return `${greeting}, ${name}!`;
    }

    // if greeting is NOT provided
    return `Hello, ${name}!`;
}

console.log(greet("Alice")); 
console.log(greet("Bob", "Good morning"));
```

---

## âœ… Output

```
Hello, Alice!
Good morning, Bob!
```

---

## ğŸ” Explanation

* `name` â†’ required
* `greeting` â†’ optional
* If greeting is passed â†’ custom message
* If not passed â†’ default "Hello"

---

# ğŸŸ¢ Example 2: Same Greeting Function (Using else)

```ts
function greet(name: string, greeting?: string): string {
    if (greeting) {
        return `${greeting}, ${name}!`;
    } else {
        return `Hello, ${name}!`;
    }
}

console.log(greet("Alice")); 
console.log(greet("Bob", "Good morning")); 
```

âœ” Both versions work the same
âœ” Only logic style is different

---

# ğŸŸ¢ Example 3: Multiple Optional Parameters

---

## âœ… Code

```ts
function createUser(username: string, age?: number, email?: string): string {
    // username is required
    // age and email are optional

    let userInfo = `Username: ${username}`;

    if (age !== undefined) {
        // if age is provided
        userInfo += `, Age: ${age}`;
    }

    if (email !== undefined) {
        // if email is provided
        userInfo += `, Email: ${email}`;
    }

    return userInfo;
}

console.log(createUser("john_doe")); 
console.log(createUser("jane_doe", 28)); 
console.log(createUser("sam_smith", 30, "sam@example.com"));
```

---

## âœ… Output

```
Username: john_doe
Username: jane_doe, Age: 28
Username: sam_smith, Age: 30, Email: sam@example.com
```

---

## ğŸ” Explanation

* `username` â†’ required
* `age` â†’ optional
* `email` â†’ optional

If age or email is not passed â†’ it remains `undefined`.

---

# ğŸ§  Important Concept: What Happens Internally?

When you define:

```ts
age?: number
```

TypeScript actually treats it like:

```ts
age: number | undefined
```

That means:

ğŸ‘‰ Age can be number
ğŸ‘‰ OR undefined

Thatâ€™s why we check:

```ts
if (age !== undefined)
```

---

# âŒ Wrong Example (Very Important)

Optional parameters must come **after required parameters**.

âŒ This is wrong:

```ts
function example(a?: number, b: number) {
}
```

âœ” Required parameter cannot come after optional.

---

# âœ… Correct Order

```ts
function example(a: number, b?: number) {
}
```

---

# â­ Best Practices

### 1ï¸âƒ£ Always Put Optional Parameters at the End

```ts
function test(a: number, b?: string) { }
```

---

### 2ï¸âƒ£ Use Default Values When Needed

Instead of:

```ts
function greet(name: string, greeting?: string)
```

You can use:

```ts
function greet(name: string, greeting: string = "Hello")
```

This avoids undefined checking.

---

### 3ï¸âƒ£ Use Union Types for More Flexibility

Example:

```ts
function example(value?: string | number) {
}
```

This means:

* value can be string
* OR number
* OR undefined

---

# ğŸ¯ Final Summary (Very Important)

| Concept        | Meaning                             |
| -------------- | ----------------------------------- |
| `?`            | Makes parameter optional            |
| Optional Value | Becomes `undefined` if not provided |
| Order Rule     | Required first, optional after      |
| Better Option  | Use default values when possible    |


# ğŸ“˜ Rest Parameters in TypeScript (Beginner Friendly Explanation)

---

# ğŸ”¹ What Are Rest Parameters?

Rest parameters allow a function to accept **unlimited number of arguments**.

Instead of writing:

```ts
function sum(a: number, b: number, c: number)
```

We can write:

```ts
function sum(...numbers: number[])
```

ğŸ‘‰ All arguments are collected into **one array**

---

# ğŸ”¹ Important Rules

âœ… Defined using `...` (three dots)
âœ… Must be the **last parameter**
âœ… Only **one rest parameter** allowed
âœ… Always an array type (`type[]`)

---

# ğŸ”¹ Basic Syntax (Very Important)

```ts
function functionName(...rest: type[]) {
    // rest is an array
}
```

---

# ğŸ” Syntax Explanation

* `...rest` â†’ collects remaining arguments
* `type[]` â†’ array of that type
* Rest parameter always becomes an array

Example meaning:

```ts
...numbers: number[]
```

ğŸ‘‰ numbers is an array of numbers

---

# ğŸŸ¢ Example 1: Sum of Numbers

```ts
function sum(...numbers: number[]): number {
    // numbers becomes an array

    return numbers.reduce((total, num) => {
        return total + num; // add each number
    }, 0); // initial value is 0
}

console.log(sum(1, 2, 3));  // 6
console.log(sum(10, 20));   // 30
```

---

## ğŸ” What Happens Internally?

Calling:

```ts
sum(1, 2, 3)
```

Is treated like:

```ts
numbers = [1, 2, 3]
```

---

# ğŸŸ¢ Example 2: Calculating Average

```ts
function average(...numbers: number[]): number {
    let total = 0;

    for (let num of numbers) {
        total += num; // add each number
    }

    // if no numbers passed, return 0
    return numbers.length === 0 ? 0 : total / numbers.length;
}

console.log("Average:", average(10, 20, 30, 60));
console.log("Average:", average(5, 6));
console.log("Average:", average(4));
```

---

# ğŸŸ¢ Example 3: Joining Strings

```ts
function joinStrings(...strings: string[]): string {
    return strings.join(', ');
}

console.log(joinStrings("rachel", "john", "peter") + " are mathematicians");
console.log(joinStrings("sarah", "joseph") + " are coders");
```

---

# âŒ Incorrect Usage (Very Important)

Rest parameter must be LAST.

âŒ Wrong:

```ts
function job(...people: string[], jobTitle: string): void {
    console.log(`${people.join(', ')} are ${jobTitle}`);
}
```

This causes error:

```
A rest parameter must be last in a parameter list.
```

---

# âœ… Correct Version

```ts
function job(jobTitle: string, ...people: string[]): void {
    console.log(`${people.join(', ')} are ${jobTitle}`);
}
```

---

# â­ Best Practices

âœ” Always put rest parameter last
âœ” Use correct type (`number[]`, `string[]`)
âœ” Use only one rest parameter
âœ” Donâ€™t overuse

---

# ğŸ“˜ TypeScript Function Overloads (Beginner Friendly)

---

# ğŸ”¹ What Are Function Overloads?

Function Overloading allows:

âœ… Same function name
âœ… Different parameter types or count
âœ… One single implementation

---

# ğŸ”¹ Basic Structure (Very Important)

```ts
// Overload Signatures
function functionName(param: type): returnType;
function functionName(param1: type, param2: type): returnType;

// Implementation
function functionName(param1: any, param2?: any): any {
    // logic here
}
```

ğŸ‘‰ Overload signatures have NO body
ğŸ‘‰ Only implementation has body

---

# ğŸŸ¢ Example 1: Greeting Function

```ts
// Overload signatures
function greet(person: string): string;
function greet(person: string, age: number): string;

// Implementation
function greet(person: string, age?: number): string {
    if (age !== undefined) {
        return `Hello, ${person}! You are ${age} years old.`;
    }

    return `Hello, ${person}!`;
}

console.log(greet("Alice"));
console.log(greet("Bob", 30));
```

---

# ğŸŸ¢ Example 2: Add Numbers or Concatenate Strings

```ts
// Overloads
function combine(a: number, b: number): number;
function combine(a: string, b: string): string;

// Implementation
function combine(a: any, b: any): any {
    return a + b;
}

console.log(combine(5, 10));               // 15
console.log(combine("Hello, ", "World!")); // Hello, World!
```

ğŸ‘‰ TypeScript ensures correct usage
ğŸ‘‰ Implementation handles both

---

# ğŸŸ¢ Example 3: Fetch Data by ID or Query

```ts
// Overloads
function fetchData(id: number): string;
function fetchData(query: string): string[];

// Implementation
function fetchData(param: any): any {
    if (typeof param === "number") {
        return `Data for ID: ${param}`;
    } else {
        return [`Result for query: ${param}`];
    }
}

console.log(fetchData(42));
console.log(fetchData("search term"));
```

---

# ğŸŸ¢ Example 4: Calculate Area (Circle or Rectangle)

```ts
// Overloads
function calculateArea(radius: number): number;
function calculateArea(length: number, width: number): number;

// Implementation
function calculateArea(...args: number[]): number {
    if (args.length === 1) {
        // Circle area
        return Math.PI * args[0] ** 2;
    } else {
        // Rectangle area
        return args[0] * args[1];
    }
}

console.log(calculateArea(5));
console.log(calculateArea(10, 20));
```

---

# ğŸ”¥ Important Rules for Overloading

âœ” Overload signatures must be above implementation
âœ” Only ONE implementation allowed
âœ” Implementation must handle all cases
âœ” Overload signatures cannot have body

---

# ğŸ¯ Final Comparison

| Concept        | Rest Parameter      | Function Overload   |
| -------------- | ------------------- | ------------------- |
| Purpose        | Unlimited arguments | Multiple call types |
| Uses           | `...`               | Multiple signatures |
| Implementation | One function        | One function        |
| Flexible       | Count-based         | Type-based          |

---

# ğŸ§  When to Use What?

Use Rest Parameter â†’ When number of arguments changes
Use Overloading â†’ When type or behavior changes

