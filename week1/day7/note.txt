Why std::array is Better than C-style Array?
1ï¸âƒ£ Knows its own size

C-style array does NOT know its size.

std::array has .size() function.

2ï¸âƒ£ Does NOT decay into pointer

C-style array converts to pointer when passed to function.

std::array does NOT decay â†’ safer.

3ï¸âƒ£ More Safe & Reliable

Has bound checking using at()

Has built-in useful functions

ğŸ”¹ How to Declare std::array
#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int, 5> arr = {10, 20, 30, 40, 50};

    cout << "First element: " << arr[0] << endl;

    return 0;
}

ğŸ‘‰ array<int, 5>

int â†’ data type

5 â†’ size (fixed at compile time)

ğŸ”¹ Important Functions (Very Simple Explanation)
1ï¸âƒ£ at() â€“ Safe Access

âœ” Checks index
âœ” Throws error if out of range

#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int, 3> arr = {1, 2, 3};

    cout << arr.at(0) << endl;   // 1
    cout << arr.at(1) << endl;   // 2

    // cout << arr.at(5);  // âŒ Runtime error (out of range)

}

ğŸ‘‰ Use at() when safety is important.

2ï¸âƒ£ operator[] â€“ Fast Access

âœ” No checking
âœ” Faster

cout << arr[2];   // 3

ğŸ‘‰ Use when you are sure index is correct.

3ï¸âƒ£ get<index>() â€“ Compile-time Access

âœ” Used with <tuple> header
âœ” Index must be constant

#include <tuple>

cout << get<0>(arr);   // 1
4ï¸âƒ£ front() and back()

âœ” front() â†’ first element
âœ” back() â†’ last element

#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int,5> arr = {10,20,30,40,50};

    cout << "First: " << arr.front() << endl;  // 10
    cout << "Last: " << arr.back() << endl;    // 50

    // Modify using reference
    arr.front() = 100;
    arr.back() = 500;

    for(auto x : arr)
        cout << x << " ";

}

Output:

100 20 30 40 500
5ï¸âƒ£ size() and max_size()

âœ” Returns number of elements
âœ” Both return same value in std::array

cout << arr.size();      // 5
cout << arr.max_size();  // 5
6ï¸âƒ£ swap()

âœ” Swap two arrays completely

#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int,3> a = {1,2,3};
    array<int,3> b = {4,5,6};

    a.swap(b);

    for(auto x : a)
        cout << x << " ";
}

Output:

4 5 6
7ï¸âƒ£ empty()

âœ” Returns true if size = 0

array<int,0> a;

if(a.empty())
    cout << "Array is empty";
8ï¸âƒ£ fill(value)

âœ” Fill entire array with same value

#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int,5> arr;

    arr.fill(9);

    for(auto x : arr)
        cout << x << " ";
}

Output:

9 9 9 9 9
ğŸ”¥ Complete Practice Program (All in One)
#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int,5> arr = {1,2,3,4,5};

    cout << "Using at(): ";
    for(int i=0;i<arr.size();i++)
        cout << arr.at(i) << " ";
    cout << endl;

    cout << "Front: " << arr.front() << endl;
    cout << "Back: " << arr.back() << endl;

    cout << "Size: " << arr.size() << endl;

    arr.fill(10);

    cout << "After fill: ";
    for(auto x : arr)
        cout << x << " ";
}
summary:
array<int,5> arr = {1,2,3,4,5};
#include <iostream>
#include <array>
using namespace std;

int main() {

    array<int,5> arr = {1,2,3,4,5};  
    // Creates an array of 5 integers and initializes it with values

    arr.at(0);       
    // Access element at index 0 with bounds checking (safe access).
    // If index is invalid, it throws an exception.

    arr[0];          
    // Access element at index 0 without bounds checking (faster but unsafe).

    arr.front();     
    // Returns the first element of the array (same as arr[0]).

    arr.back();      
    // Returns the last element of the array (here arr[4]).

    arr.size();      
    // Returns the total number of elements in the array (here 5).

    array<int,5> arr2 = {10,20,30,40,50};  
    // Another array of same size for swapping

    arr.swap(arr2);  
    // Swaps all elements of arr with arr2.

    arr.fill(9);     
    // Replaces all elements of the array with the value 9.

    arr.empty();     
    // Returns true if array size is 0, otherwise false.
    // (Here it will return false because size is 5.)

    return 0;
}
ğŸ¯ When to Use std::array?


âœ” When size is fixed
âœ” When you want safe STL container
âœ” When you need better features than C array



std::vector is a dynamic array provided by the C++ Standard Template Library (STL).
It automatically resizes itself when elements are added or removed.

Unlike normal arrays:

Size is flexible (can grow/shrink)

Memory management is automatic

Provides many built-in useful functions

Header file:

#include <vector>
1ï¸âƒ£ Declaration & Initialization
ğŸ”¹ Basic Declaration
vector<int> v;   // Empty vector of integers
ğŸ”¹ Fixed Size with Initial Value
vector<int> v(3, 5);  // {5,5,5}

3 â†’ size

5 â†’ initial value

ğŸ”¹ Using Initializer List
vector<int> v = {1,2,3};
2ï¸âƒ£ Internal Working of Vector

Vector internally maintains:

size() â†’ number of elements

capacity() â†’ allocated memory space

When size exceeds capacity:

Vector reallocates larger memory

Copies old elements

Deletes old memory

âš  Reallocation is costly (O(n)), but happens rarely.
Average insertion at end â†’ O(1).

3ï¸âƒ£ Important Operations in Vector
ğŸ”¹ INSERT ELEMENTS
âœ… push_back()

Adds element at end.

v.push_back(10);

Time Complexity â†’ O(1) average

Fastest way to insert

âœ… insert()

Insert at specific position.

v.insert(v.begin()+1, 50);

Shifts elements

Time Complexity â†’ O(n)

ğŸ”¹ ACCESS ELEMENTS
âœ… Using []
cout << v[2];

No bounds checking

Fast

Dangerous if index invalid

âœ… Using at()
cout << v.at(2);

Performs bounds checking

Throws out_of_range exception

Safer

Time complexity â†’ O(1)

ğŸ”¹ UPDATE ELEMENT
v[1] = 100;

Direct replacement

O(1)

ğŸ”¹ FIND SIZE
v.size();

Returns number of elements.

ğŸ”¹ TRAVERSE VECTOR
Using Index Loop
for(int i=0;i<v.size();i++)
    cout<<v[i];
Using Range-Based Loop
for(int x : v)
    cout<<x;

Time Complexity â†’ O(n)

ğŸ”¹ DELETE ELEMENTS
âœ… pop_back()

Removes last element.

v.pop_back();

Time Complexity â†’ O(1)

âœ… erase()

Remove specific element using iterator.

v.erase(v.begin()+2);

Time Complexity â†’ O(n)

ğŸ”¹ CHECK EMPTY
v.empty();

Returns:

true â†’ if empty

false â†’ otherwise

4ï¸âƒ£ 2D Vector (Matrix)
Declaration
vector<vector<int>> matrix;
Initialization
vector<vector<int>> matrix(3, vector<int>(4,0));

3 rows, 4 columns filled with 0.

Access
matrix[i][j];
Traversal
for(int i=0;i<matrix.size();i++){
    for(int j=0;j<matrix[i].size();j++){
        cout<<matrix[i][j];
    }
}
5ï¸âƒ£ Time Complexity Summary
Operation	Time Complexity
push_back()	O(1) average
insert()	O(n)
erase()	O(n)
pop_back()	O(1)
access []	O(1)
at()	O(1)
size()	O(1)
traverse	O(n)
6ï¸âƒ£ Important Member Functions (Complete Summary in Code Form)

Below is a complete summary program with comments explaining each vector member function:

#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {

    vector<int> v;  

    v.push_back(10);   // Adds element at end (O(1) average)
    v.push_back(20);
    v.push_back(30);

    cout << "Size: " << v.size() << endl;       
    // size() -> returns number of elements

    cout << "Capacity: " << v.capacity() << endl;  
    // capacity() -> returns allocated memory

    cout << "First element: " << v.front() << endl; 
    // front() -> returns first element

    cout << "Last element: " << v.back() << endl;   
    // back() -> returns last element

    cout << "Element at index 1: " << v.at(1) << endl;  
    // at(i) -> safe access with bounds checking

    v[1] = 50;  
    // [] -> direct access (no bounds checking)

    v.insert(v.begin()+1, 100);  
    // insert(pos,value) -> insert at position (O(n))

    v.erase(v.begin());  
    // erase(pos) -> delete element at position (O(n))

    v.pop_back();  
    // pop_back() -> removes last element (O(1))

    if(v.empty())  
        cout << "Vector is empty\n";
    else
        cout << "Vector is not empty\n";
    // empty() -> checks if vector is empty

    v.clear();  
    // clear() -> removes all elements

    return 0;
}
7ï¸âƒ£ When To Use Vector vs Array
Use Vector When:

âœ” Size is dynamic
âœ” Frequent insertions at end
âœ” Need STL compatibility

Use Array When:

âœ” Fixed size
âœ” Performance extremely critical
âœ” No dynamic resizing required

1ï¸âƒ£ What is Deque?

A deque is similar to vector, but:

Feature	vector	deque
Insert at back	Fast	Fast
Insert at front	Slow (O(n))	Fast (O(1))
Random access	Yes	Yes
Memory	Contiguous	Non-contiguous blocks

ğŸ‘‰ deque internally uses multiple memory blocks, not a single continuous memory like vector.

This is why:

It efficiently grows from both sides

It does not reallocate entire memory like vector

2ï¸âƒ£ Declaration & Initialization
ğŸ”¹ Empty deque
deque<int> d;
ğŸ”¹ Using initializer list
deque<int> d = {10,20,30,40};
3ï¸âƒ£ Insertion Operations
âœ… push_back()

Adds element at end.

d.push_back(10);

âœ” Time Complexity â†’ O(1) amortized
âœ” Used like queue enqueue

âœ… push_front()

Adds element at beginning.

d.push_front(5);

âœ” Time Complexity â†’ O(1) amortized
âœ” Very powerful feature (vector does not support this efficiently)

4ï¸âƒ£ Deletion Operations
âœ… pop_back()

Removes last element.

d.pop_back();

âœ” O(1) amortized

âœ… pop_front()

Removes first element.

d.pop_front();

âœ” O(1) amortized

5ï¸âƒ£ Accessing Elements
âœ… Using front()
d.front();

Returns first element (does not remove)

âœ… Using back()
d.back();

Returns last element

âœ… Using index operator []
d[2];

âœ” Random access supported
âœ” Time Complexity â†’ O(1)

6ï¸âƒ£ Size & Empty
âœ… size()
d.size();

Returns number of elements

âœ… empty()
d.empty();

Returns:

true â†’ if empty

false â†’ otherwise

7ï¸âƒ£ clear()
d.clear();

Removes all elements
Size becomes 0

8ï¸âƒ£ Insert & Erase at Arbitrary Position
insert()
d.insert(d.begin()+2, 100);

âœ” O(n)

erase()
d.erase(d.begin()+1);

âœ” O(n)

9ï¸âƒ£ Time Complexity Table
Operation	Time Complexity
push_back()	O(1) amortized
push_front()	O(1) amortized
pop_back()	O(1) amortized
pop_front()	O(1) amortized
insert(pos)	O(n)
erase(pos)	O(n)
access by index	O(1)
iterate	O(n)
ğŸ”Ÿ Deque vs Queue
Feature	Queue	Deque
Insert	Rear only	Front & Rear
Delete	Front only	Front & Rear
Behavior	FIFO	FIFO + LIFO
Flexibility	Limited	More flexible
1ï¸âƒ£1ï¸âƒ£ When To Use Deque?

âœ” Sliding Window Problems
âœ” Palindrome Checking
âœ” Implementing Stack + Queue together
âœ” When insertion/deletion required from both ends

1ï¸âƒ£2ï¸âƒ£ Complete Member Function Summary (With Comments)

Below is full summary program with explanation of all major deque member functions:

#include <iostream>
#include <deque>
using namespace std;

int main() {

    deque<int> d;

    d.push_back(10);    
    // push_back() -> Insert element at end (O(1))

    d.push_front(5);    
    // push_front() -> Insert element at beginning (O(1))

    cout << "First element: " << d.front() << endl;
    // front() -> Returns first element

    cout << "Last element: " << d.back() << endl;
    // back() -> Returns last element

    cout << "Element at index 1: " << d[1] << endl;
    // [] -> Random access (O(1))

    cout << "Size: " << d.size() << endl;
    // size() -> Returns number of elements

    if(d.empty())
        cout << "Deque is empty\n";
    else
        cout << "Deque is not empty\n";
    // empty() -> Checks if deque is empty

    d.insert(d.begin()+1, 100);
    // insert(pos,value) -> Insert at given position (O(n))

    d.erase(d.begin());
    // erase(pos) -> Remove element at position (O(n))

    d.pop_back();
    // pop_back() -> Remove last element (O(1))

    d.pop_front();
    // pop_front() -> Remove first element (O(1))

    d.clear();
    // clear() -> Removes all elements

    return 0;
}

std::list is a sequence container in C++ STL.

It is implemented as a Doubly Linked List.

That means:

Each node stores data

One pointer to next node

One pointer to previous node

Header file:

#include <list>
1ï¸âƒ£ What is List?

A list:

âœ” Stores elements in non-contiguous memory
âœ” Allows fast insertion/deletion anywhere
âœ” Maintains front and back
âœ” Does NOT support random access

2ï¸âƒ£ Declaration & Initialization
ğŸ”¹ Empty list
list<int> l;
ğŸ”¹ Using initializer list
list<int> l = {1,2,3};
3ï¸âƒ£ Internal Working

Since it is a doubly linked list:

Each node contains:

[prev pointer | data | next pointer]

So:

Insertion/deletion â†’ O(1) (if iterator known)

Random access â†’ âŒ Not allowed (O(n))

4ï¸âƒ£ Inserting Elements
âœ… push_back()

Insert at end

l.push_back(10);   // O(1)
âœ… push_front()

Insert at beginning

l.push_front(5);   // O(1)
âœ… insert()

Insert at specific position using iterator

auto it = l.begin();
advance(it,2);
l.insert(it,100);   // O(1) if position known

âš  If position unknown â†’ traversal O(n)

5ï¸âƒ£ Accessing Elements

âŒ No random access like l[2]

âœ… front()
l.front();

Returns first element

âœ… back()
l.back();

Returns last element

âœ… Access using iterator
auto it = next(l.begin(),2);
cout << *it;

Time Complexity â†’ O(n)

6ï¸âƒ£ Updating Elements

Must use iterator:

auto it = l.begin();
advance(it,2);
*it = 50;

âœ” O(n) to reach position
âœ” O(1) to update

7ï¸âƒ£ Finding Elements

Use find() from <algorithm>

#include <algorithm>

auto it = find(l.begin(), l.end(), 4);

âœ” Returns iterator
âœ” If not found â†’ returns l.end()
âœ” Time Complexity â†’ O(n)

8ï¸âƒ£ Traversing List
Using iterator
for(auto it=l.begin(); it!=l.end(); ++it)
    cout << *it << " ";
Using range-based loop
for(int x : l)
    cout << x << " ";

Time Complexity â†’ O(n)

9ï¸âƒ£ Deleting Elements
âœ… pop_back()
l.pop_back();   // O(1)
âœ… pop_front()
l.pop_front();   // O(1)
âœ… erase()
auto it = l.begin();
advance(it,2);
l.erase(it);   // O(1)

âš  Traversal to position â†’ O(n)

ğŸ”Ÿ Important Member Functions
Function	Use
size()	Returns number of elements
empty()	Checks if list empty
clear()	Removes all elements
front()	First element
back()	Last element
insert()	Insert at position
erase()	Remove at position
push_front()	Insert at start
push_back()	Insert at end
pop_front()	Remove first
pop_back()	Remove last
rbegin()	Reverse begin iterator
rend()	Reverse end iterator
1ï¸âƒ£1ï¸âƒ£ Time Complexity Table
Operation	Time Complexity
push_front()	O(1)
push_back()	O(1)
insert()	O(1) if iterator known
erase()	O(1) if iterator known
access by index	âŒ Not allowed
search	O(n)
traversal	O(n)
1ï¸âƒ£2ï¸âƒ£ List vs Vector vs Deque
Feature	vector	deque	list
Memory	Contiguous	Block-based	Non-contiguous
Random access	O(1)	O(1)	âŒ
Insert front	O(n)	O(1)	O(1)
Insert middle	O(n)	O(n)	O(1)
Insert back	O(1)	O(1)	O(1)
Best for	Dynamic array	Double ended ops	Frequent insert/delete
1ï¸âƒ£3ï¸âƒ£ forward_list vs list
Feature	forward_list	list
Type	Singly Linked	Doubly Linked
Memory	Less	More
Reverse traversal	âŒ	âœ”
size() function	âŒ	âœ”
Iterators	Forward only	Bidirectional
1ï¸âƒ£4ï¸âƒ£ Complete Member Function Summary (With Comments)
#include <iostream>
#include <list>
#include <algorithm>
using namespace std;

int main() {

    list<int> l;

    l.push_back(10);
    // push_back() -> Insert at end (O(1))

    l.push_front(5);
    // push_front() -> Insert at beginning (O(1))

    cout << "First: " << l.front() << endl;
    // front() -> Returns first element

    cout << "Last: " << l.back() << endl;
    // back() -> Returns last element

    cout << "Size: " << l.size() << endl;
    // size() -> Number of elements

    if(l.empty())
        cout << "List is empty\n";
    // empty() -> Checks if list is empty

    auto it = l.begin();
    l.insert(it,100);
    // insert(pos,value) -> Insert before pos (O(1))

    it = find(l.begin(), l.end(), 10);
    // find() -> Search element (O(n))

    if(it != l.end())
        l.erase(it);
    // erase(pos) -> Remove element at position (O(1))

    l.pop_front();
    // pop_front() -> Remove first element

    l.pop_back();
    // pop_back() -> Remove last element

    l.clear();
    // clear() -> Remove all elements

    return 0;
}
ğŸ¯ Final Summary

A list in C++:

âœ” Implemented as doubly linked list
âœ” Fast insertion/deletion anywhere
âœ” No random access
âœ” Uses more memory than vector
âœ” Best for frequent middle insert/delete

What is forward_list?

std::forward_list is a singly linked list container in C++ STL.

âœ” Stores elements in non-contiguous memory
âœ” Each node points to next element only
âœ” Supports only forward traversal
âœ” Very memory efficient
âœ” Fast insertion/deletion after known position

Header file:

#include <forward_list>
ğŸ”¹ Syntax
forward_list<int> fl;
ğŸ”¹ Short Main Example (All Basic Operations)
#include <iostream>
#include <forward_list>
#include <algorithm>
using namespace std;

int main() {

    forward_list<int> fl = {10, 20, 30};

    fl.push_front(5);   
    // push_front() -> Insert at front (O(1))

    cout << "First element: " << fl.front() << endl;
    // front() -> Access first element

    auto it = fl.begin();
    advance(it,1);
    fl.insert_after(it, 25);
    // insert_after(pos,value) -> Insert after position

    fl.pop_front();
    // pop_front() -> Remove first element

    fl.erase_after(fl.begin());
    // erase_after(pos) -> Remove element after pos

    // Traversal
    for(int x : fl)
        cout << x << " ";

    cout << endl;

    // Check empty
    if(fl.empty())
        cout << "Empty\n";
    else
        cout << "Not Empty\n";

    return 0;
}
ğŸ”¹ Important Member Functions (Summary)
Function	Use
push_front()	Insert at beginning
pop_front()	Remove first element
insert_after()	Insert after given iterator
erase_after()	Remove element after iterator
front()	Access first element
empty()	Check if empty
clear()	Remove all elements
begin()	Iterator to first element
end()	Iterator to end
before_begin()	Iterator before first element

âš  No size() function
âš  No push_back()
âš  No reverse iterators

ğŸ”¥ forward_list vs list (Important Difference)
Feature	forward_list	list
Type	Singly Linked List	Doubly Linked List
Pointers per node	1 (next)	2 (prev + next)
Memory usage	Less	More
Traversal	Forward only	Forward + Backward
Reverse iterator	âŒ No	âœ” Yes
size() function	âŒ No	âœ” Yes
push_back()	âŒ No	âœ” Yes
insert()	insert_after() only	insert() before position
Best for	Memory optimization	Flexible operations
ğŸ”¹ Time Complexity
Operation	Time
push_front()	O(1)
pop_front()	O(1)
insert_after()	O(1)
erase_after()	O(1)
search	O(n)
traversal	O(n)
ğŸ”¹ When To Use forward_list?

âœ” When memory is limited
âœ” When only forward traversal required
âœ” When mostly insertion/deletion from front
âœ” When size() not required

ğŸ¯ Final Summary

forward_list:

Singly linked list

Lightweight

Only forward movement

Fast insert/delete after known position

No random access

No size() function