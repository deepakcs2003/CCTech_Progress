<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ STL Containers - Complete Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f5f5f5;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        h1 {
            color: #2c3e50;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
            margin-bottom: 30px;
            font-size: 2.5em;
        }

        h2 {
            color: #2980b9;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-left: 5px solid #3498db;
            padding-left: 15px;
        }

        h3 {
            color: #34495e;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        p {
            margin-bottom: 15px;
            font-size: 1.05em;
        }

        /* VS Code Style Code Blocks */
        pre {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.95em;
            color: #e83e8c;
        }

        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        /* Syntax Highlighting */
        .keyword { color: #569cd6; }
        .string { color: #ce9178; }
        .comment { color: #6a9955; font-style: italic; }
        .function { color: #dcdcaa; }
        .number { color: #b5cea8; }
        .type { color: #4ec9b0; }

        /* Lists */
        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 10px;
            font-size: 1.05em;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 25px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        th {
            background: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        /* Highlight Boxes */
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .success-box {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .comparison-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border: 2px solid #dee2e6;
        }

        .comparison-item h4 {
            color: #495057;
            margin-bottom: 10px;
        }

        strong {
            color: #2c3e50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìö C++ STL Containers - Complete Guide</h1>

        <!-- ==================== ARRAY ==================== -->
        <h2>1Ô∏è‚É£ std::array - Fixed Size Container</h2>
        
        <div class="info-box">
            <strong>Key Concept:</strong> std::array is a wrapper around C-style arrays with added safety and functionality. Size is fixed at compile time.
        </div>

        <h3>Why std::array over C-style array?</h3>
        <ul>
            <li><strong>Knows its size:</strong> Has <code>.size()</code> function</li>
            <li><strong>No pointer decay:</strong> Safer when passed to functions</li>
            <li><strong>Bounds checking:</strong> Use <code>.at()</code> for safe access</li>
            <li><strong>STL compatibility:</strong> Works with algorithms and iterators</li>
        </ul>

        <h3>Declaration & Initialization</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;array&gt;</span>
<span class="keyword">using namespace</span> std;

<span class="type">array</span>&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; arr = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};
<span class="comment">// array&lt;type, size&gt; name = {values};</span></code></pre>

        <h3>Essential Functions</h3>
        <pre><code><span class="comment">// Access (Safe - with bounds checking)</span>
arr.<span class="function">at</span>(<span class="number">0</span>);           <span class="comment">// Throws exception if out of range</span>

<span class="comment">// Access (Fast - no checking)</span>
arr[<span class="number">0</span>];              <span class="comment">// Faster but unsafe</span>

<span class="comment">// First and Last Elements</span>
arr.<span class="function">front</span>();          <span class="comment">// First element</span>
arr.<span class="function">back</span>();           <span class="comment">// Last element</span>

<span class="comment">// Size Operations</span>
arr.<span class="function">size</span>();           <span class="comment">// Number of elements</span>
arr.<span class="function">empty</span>();          <span class="comment">// Returns true if size = 0</span>

<span class="comment">// Modify All Elements</span>
arr.<span class="function">fill</span>(<span class="number">9</span>);          <span class="comment">// Fill entire array with value 9</span>

<span class="comment">// Swap Arrays</span>
arr.<span class="function">swap</span>(arr2);       <span class="comment">// Swap all elements with another array</span></code></pre>

        <h3>Complete Example</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;iostream&gt;</span>
<span class="keyword">#include</span> <span class="string">&lt;array&gt;</span>
<span class="keyword">using namespace</span> std;

<span class="keyword">int</span> <span class="function">main</span>() {
    <span class="type">array</span>&lt;<span class="keyword">int</span>, <span class="number">5</span>&gt; arr = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};
    
    cout &lt;&lt; <span class="string">"First: "</span> &lt;&lt; arr.<span class="function">front</span>() &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Last: "</span> &lt;&lt; arr.<span class="function">back</span>() &lt;&lt; endl;
    cout &lt;&lt; <span class="string">"Size: "</span> &lt;&lt; arr.<span class="function">size</span>() &lt;&lt; endl;
    
    arr.<span class="function">fill</span>(<span class="number">10</span>);
    
    <span class="keyword">for</span>(<span class="keyword">auto</span> x : arr)
        cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;
    
    <span class="keyword">return</span> <span class="number">0</span>;
}</code></pre>

        <!-- ==================== VECTOR ==================== -->
        <h2>2Ô∏è‚É£ std::vector - Dynamic Array</h2>

        <div class="info-box">
            <strong>Key Concept:</strong> Dynamic array that automatically resizes. Memory is contiguous. Best for dynamic data with frequent access.
        </div>

        <h3>Declaration & Initialization</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;vector&gt;</span>

<span class="type">vector</span>&lt;<span class="keyword">int</span>&gt; v;                    <span class="comment">// Empty vector</span>
<span class="type">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">5</span>, <span class="number">10</span>);            <span class="comment">// Size 5, all values = 10</span>
<span class="type">vector</span>&lt;<span class="keyword">int</span>&gt; v = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};      <span class="comment">// Initializer list</span></code></pre>

        <h3>Core Operations</h3>
        <pre><code><span class="comment">// Insert Elements</span>
v.<span class="function">push_back</span>(<span class="number">10</span>);               <span class="comment">// Add at end - O(1) average</span>
v.<span class="function">insert</span>(v.<span class="function">begin</span>()+<span class="number">1</span>, <span class="number">50</span>);  <span class="comment">// Insert at position - O(n)</span>

<span class="comment">// Access Elements</span>
v[<span class="number">2</span>];                         <span class="comment">// Fast, no bounds check</span>
v.<span class="function">at</span>(<span class="number">2</span>);                      <span class="comment">// Safe, with bounds check</span>
v.<span class="function">front</span>();                    <span class="comment">// First element</span>
v.<span class="function">back</span>();                     <span class="comment">// Last element</span>

<span class="comment">// Delete Elements</span>
v.<span class="function">pop_back</span>();                <span class="comment">// Remove last - O(1)</span>
v.<span class="function">erase</span>(v.<span class="function">begin</span>()+<span class="number">2</span>);       <span class="comment">// Remove at position - O(n)</span>
v.<span class="function">clear</span>();                    <span class="comment">// Remove all elements</span>

<span class="comment">// Size & Capacity</span>
v.<span class="function">size</span>();                    <span class="comment">// Number of elements</span>
v.<span class="function">capacity</span>();                <span class="comment">// Allocated memory space</span>
v.<span class="function">empty</span>();                   <span class="comment">// Check if empty</span></code></pre>

        <h3>2D Vector (Matrix)</h3>
        <pre><code><span class="comment">// Declaration: 3 rows, 4 columns, all zeros</span>
<span class="type">vector</span>&lt;<span class="type">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; matrix(<span class="number">3</span>, <span class="type">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">0</span>));

<span class="comment">// Access</span>
matrix[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">5</span>;

<span class="comment">// Traverse</span>
<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix.<span class="function">size</span>(); i++) {
    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; matrix[i].<span class="function">size</span>(); j++) {
        cout &lt;&lt; matrix[i][j] &lt;&lt; <span class="string">" "</span>;
    }
}</code></pre>

        <h3>Time Complexity</h3>
        <table>
            <tr><th>Operation</th><th>Time Complexity</th></tr>
            <tr><td>push_back()</td><td>O(1) average</td></tr>
            <tr><td>insert()</td><td>O(n)</td></tr>
            <tr><td>erase()</td><td>O(n)</td></tr>
            <tr><td>pop_back()</td><td>O(1)</td></tr>
            <tr><td>access [] or at()</td><td>O(1)</td></tr>
            <tr><td>size()</td><td>O(1)</td></tr>
        </table>

        <!-- ==================== DEQUE ==================== -->
        <h2>3Ô∏è‚É£ std::deque - Double-Ended Queue</h2>

        <div class="info-box">
            <strong>Key Concept:</strong> Efficient insertion/deletion at both ends. Uses non-contiguous memory blocks. Supports random access.
        </div>

        <h3>Declaration</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;deque&gt;</span>

<span class="type">deque</span>&lt;<span class="keyword">int</span>&gt; d;
<span class="type">deque</span>&lt;<span class="keyword">int</span>&gt; d = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};</code></pre>

        <h3>Core Operations</h3>
        <pre><code><span class="comment">// Insert at Both Ends - O(1)</span>
d.<span class="function">push_back</span>(<span class="number">10</span>);      <span class="comment">// Add at end</span>
d.<span class="function">push_front</span>(<span class="number">5</span>);     <span class="comment">// Add at beginning (advantage over vector!)</span>

<span class="comment">// Delete from Both Ends - O(1)</span>
d.<span class="function">pop_back</span>();         <span class="comment">// Remove last</span>
d.<span class="function">pop_front</span>();        <span class="comment">// Remove first</span>

<span class="comment">// Access - O(1)</span>
d[<span class="number">2</span>];                 <span class="comment">// Random access</span>
d.<span class="function">front</span>();            <span class="comment">// First element</span>
d.<span class="function">back</span>();             <span class="comment">// Last element</span>

<span class="comment">// Other Operations</span>
d.<span class="function">size</span>();
d.<span class="function">empty</span>();
d.<span class="function">clear</span>();
d.<span class="function">insert</span>(d.<span class="function">begin</span>()+<span class="number">2</span>, <span class="number">100</span>);  <span class="comment">// O(n)</span>
d.<span class="function">erase</span>(d.<span class="function">begin</span>()+<span class="number">1</span>);        <span class="comment">// O(n)</span></code></pre>

        <div class="success-box">
            <strong>Use deque when:</strong> You need fast insertion/deletion at both ends (sliding window problems, implementing stack + queue together).
        </div>

        <!-- ==================== LIST ==================== -->
        <h2>4Ô∏è‚É£ std::list - Doubly Linked List</h2>

        <div class="info-box">
            <strong>Key Concept:</strong> Non-contiguous memory. Fast insertion/deletion anywhere if iterator is known. No random access.
        </div>

        <h3>Declaration</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;list&gt;</span>

<span class="type">list</span>&lt;<span class="keyword">int</span>&gt; l;
<span class="type">list</span>&lt;<span class="keyword">int</span>&gt; l = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</code></pre>

        <h3>Core Operations</h3>
        <pre><code><span class="comment">// Insert - O(1) if position known</span>
l.<span class="function">push_back</span>(<span class="number">10</span>);
l.<span class="function">push_front</span>(<span class="number">5</span>);
<span class="keyword">auto</span> it = l.<span class="function">begin</span>();
<span class="function">advance</span>(it, <span class="number">2</span>);
l.<span class="function">insert</span>(it, <span class="number">100</span>);

<span class="comment">// Access - NO RANDOM ACCESS!</span>
l.<span class="function">front</span>();           <span class="comment">// First element</span>
l.<span class="function">back</span>();            <span class="comment">// Last element</span>
<span class="comment">// l[2] - NOT ALLOWED!</span>

<span class="comment">// Delete - O(1) if position known</span>
l.<span class="function">pop_back</span>();
l.<span class="function">pop_front</span>();
l.<span class="function">erase</span>(it);

<span class="comment">// Search - O(n)</span>
<span class="keyword">auto</span> it = <span class="function">find</span>(l.<span class="function">begin</span>(), l.<span class="function">end</span>(), <span class="number">4</span>);

<span class="comment">// Traverse</span>
<span class="keyword">for</span>(<span class="keyword">int</span> x : l)
    cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</code></pre>

        <div class="warning-box">
            <strong>Important:</strong> list does NOT support random access like <code>l[2]</code>. Use iterators to navigate.
        </div>

        <!-- ==================== FORWARD_LIST ==================== -->
        <h2>5Ô∏è‚É£ std::forward_list - Singly Linked List</h2>

        <div class="info-box">
            <strong>Key Concept:</strong> Most memory-efficient. Only forward traversal. Each node has one pointer (next only).
        </div>

        <h3>Declaration & Operations</h3>
        <pre><code><span class="keyword">#include</span> <span class="string">&lt;forward_list&gt;</span>

<span class="type">forward_list</span>&lt;<span class="keyword">int</span>&gt; fl = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>};

<span class="comment">// Insert/Delete - O(1)</span>
fl.<span class="function">push_front</span>(<span class="number">5</span>);                  <span class="comment">// Insert at beginning</span>
fl.<span class="function">pop_front</span>();                     <span class="comment">// Remove first</span>
fl.<span class="function">insert_after</span>(fl.<span class="function">begin</span>(), <span class="number">25</span>);  <span class="comment">// Insert AFTER position</span>
fl.<span class="function">erase_after</span>(fl.<span class="function">begin</span>());       <span class="comment">// Remove AFTER position</span>

<span class="comment">// Access</span>
fl.<span class="function">front</span>();                        <span class="comment">// First element only</span>

<span class="comment">// Check empty</span>
fl.<span class="function">empty</span>();</code></pre>

        <div class="warning-box">
            <strong>Limitations:</strong>
            <ul>
                <li>No <code>size()</code> function</li>
                <li>No <code>push_back()</code></li>
                <li>No reverse iterators</li>
                <li>No <code>back()</code> function</li>
            </ul>
        </div>

        <!-- ==================== COMPARISON ==================== -->
        <h2>üìä Container Comparison</h2>

        <h3>Vector vs Deque vs List vs Forward_list</h3>
        <table>
            <tr>
                <th>Feature</th>
                <th>vector</th>
                <th>deque</th>
                <th>list</th>
                <th>forward_list</th>
            </tr>
            <tr>
                <td>Memory</td>
                <td>Contiguous</td>
                <td>Block-based</td>
                <td>Non-contiguous</td>
                <td>Non-contiguous</td>
            </tr>
            <tr>
                <td>Random Access</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>‚ùå No</td>
                <td>‚ùå No</td>
            </tr>
            <tr>
                <td>Insert Front</td>
                <td>O(n)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
            </tr>
            <tr>
                <td>Insert Middle</td>
                <td>O(n)</td>
                <td>O(n)</td>
                <td>O(1)*</td>
                <td>O(1)*</td>
            </tr>
            <tr>
                <td>Insert Back</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>O(1)</td>
                <td>‚ùå No</td>
            </tr>
            <tr>
                <td>Traversal</td>
                <td>Forward</td>
                <td>Both</td>
                <td>Both</td>
                <td>Forward only</td>
            </tr>
            <tr>
                <td>Memory per node</td>
                <td>Low</td>
                <td>Medium</td>
                <td>High (2 pointers)</td>
                <td>Low (1 pointer)</td>
            </tr>
            <tr>
                <td>size() function</td>
                <td>‚úÖ Yes</td>
                <td>‚úÖ Yes</td>
                <td>‚úÖ Yes</td>
                <td>‚ùå No</td>
            </tr>
        </table>
        <p><small>* If iterator position is already known</small></p>

        <h3>When to Use Which Container?</h3>
        <div class="comparison">
            <div class="comparison-item">
                <h4>Use std::array</h4>
                <ul>
                    <li>Fixed size known at compile time</li>
                    <li>Need STL benefits over C array</li>
                    <li>Small data sets</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Use std::vector</h4>
                <ul>
                    <li>Dynamic size needed</li>
                    <li>Frequent random access</li>
                    <li>Insertions mostly at end</li>
                    <li><strong>Default choice for most cases</strong></li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Use std::deque</h4>
                <ul>
                    <li>Insert/delete at both ends</li>
                    <li>Sliding window problems</li>
                    <li>Implementing stack + queue</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Use std::list</h4>
                <ul>
                    <li>Frequent insert/delete in middle</li>
                    <li>No random access needed</li>
                    <li>Bidirectional traversal required</li>
                </ul>
            </div>
            <div class="comparison-item">
                <h4>Use std::forward_list</h4>
                <ul>
                    <li>Memory is very limited</li>
                    <li>Only forward traversal needed</li>
                    <li>Mostly front insertions</li>
                </ul>
            </div>
        </div>

        <!-- ==================== QUICK REFERENCE ==================== -->
        <h2>‚ö° Quick Reference</h2>

        <h3>Common Functions Across Containers</h3>
        <table>
            <tr>
                <th>Function</th>
                <th>array</th>
                <th>vector</th>
                <th>deque</th>
                <th>list</th>
                <th>forward_list</th>
            </tr>
            <tr>
                <td>push_back()</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>push_front()</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>pop_back()</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>pop_front()</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>front()</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>back()</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>size()</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>empty()</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>clear()</td>
                <td>‚ùå</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
            </tr>
            <tr>
                <td>operator[]</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
            </tr>
            <tr>
                <td>at()</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
            </tr>
        </table>

        <!-- ==================== TIPS ==================== -->
        <h2>üí° Key Takeaways</h2>

        <div class="success-box">
            <h3>Memory & Performance</h3>
            <ul>
                <li><strong>Contiguous memory (cache-friendly):</strong> array, vector</li>
                <li><strong>Best random access:</strong> array, vector, deque</li>
                <li><strong>Best for front operations:</strong> deque, list, forward_list</li>
                <li><strong>Most memory efficient:</strong> forward_list</li>
                <li><strong>General purpose:</strong> vector (use this when unsure)</li>
            </ul>
        </div>

        <div class="info-box">
            <h3>Safety vs Speed</h3>
            <ul>
                <li>Use <code>.at()</code> for safety (throws exception on invalid index)</li>
                <li>Use <code>[]</code> for speed (no bounds checking)</li>
                <li>Always prefer STL containers over C-style arrays</li>
            </ul>
        </div>

        <div class="warning-box">
            <h3>Common Pitfalls</h3>
            <ul>
                <li>Don't use <code>[]</code> on list or forward_list (not supported)</li>
                <li>forward_list has no <code>size()</code> - by design for efficiency</li>
                <li>Vector reallocation invalidates iterators/pointers</li>
                <li>Use <code>reserve()</code> on vector if size is predictable</li>
            </ul>
        </div>

    </div>
</body>
</html>